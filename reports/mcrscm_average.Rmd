---
title: MCRSCM simulation results
author: "Dániel Vörös"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    self_contained: false
params:
  cache.path:
    label: Set path of cache folder
    value: report_cache/
  dir:
    label: Path to data dir
    value: "/home/danielred/data/programs/mcrs_to_scm/OUT/A7retest.6_5/"
  ssh:
    label: SSH address in format of user@domain:port
    value: ""
  ssh_key:
    label: Location of ssh public key
    value: ~/.ssh/id_rsa
  force:
    label: To force the document to regenerate all its plots
    value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r, setup, include=FALSE, message=F}
message("\ncache.path: ", params$cache.path,
        "\ndir: ", params$dir, 
        "\nssh: ", params$ssh, 
        "\nssh_key: ", params$ssh_key )

# set this option in the first code chunk in the document
knitr::opts_chunk$set(echo = F, cache.path=params$cache.path, cache.lazy = FALSE )

# libraries
library(RColorBrewer)
library(ggplot2)
library(tidyr)
library(lattice)
library(scales)
library(knitr)
library(dplyr)
library(plotly)

# add_log <- function(x) {
#   layout(x, #title = 'myplot',
#             updatemenus = list(list(
#                 active = 0,
#                 direction="right",
#                 #type="buttons",
#                 buttons= list(
#                   list(label = 'linear',
#                        method = 'update',
#                        args = list(
#                          list(visible = c(T,F)), 
#                          list(yaxis = list(type = 'linear'), xaxis = list(type = 'linear'))
#                          )
#                        ),
#                   list(label = 'log-log',
#                        method = 'update', 
#                        args = list(list(visible = c(T,F)), list(yaxis = list(type = 'log'), xaxis = list(type = 'log')))), 
#                   list(label = 'log y',
#                        method = 'update', 
#                        args = list(list(visible = c(T,F)), list(yaxis = list(type = 'log'), xaxis = list(type = 'linear')))), 
#                   list(label = 'log x',
#                        method = 'update', 
#                        args = list(list(visible = c(T,F)), list(xaxis = list(type = 'log'), yaxis = list(type = 'linear')))) 
#                 )
#             ))
#   ) |> config(displaylogo = FALSE)
# }

par.orig <- par(no.readonly = T) # save default parameters

ssh <- ifelse(nchar(params$ssh)==0, NA, params$ssh)

```

```{r load_funcs, cache=T}
source("../functions.R")
```

# simulation properties

```{r get_params, cache=T}
pf <- get_file("SAVE/parameters.txt", params$dir, ssh=ssh, ssh_key = params$ssh_key)
  if(!is.na(pf)){
    t <- readLines(pf)
    t <- read.table( text = sub(" ", "\t", t) , header=F, sep="\t")
    
    if(!is.na(params$ssh)) file.remove(pf)
    
    write.table(t, file="parameters.tsv", sep="\t", col.names = F, row.names = F)
    
    p <- as.list(as.character(t$V2))
    names(p) <- t$V1
  }
```


Simulation ID: **`r p$par_ID`**

Parameters:

```{r output_paramtable, cache=T, dependson="get_params"}
knitr::kable(unlist(p))
```

# Figures

```{r check_table}
# needed_file: the file I want to check if it has changed
# table: the data from needed_file
# output_refreshed: vaiable indicating if 

needed_file <- "output.csv"

hash <- get_mtime(needed_file, path=params$dir, ssh=ssh, ssh_key=params$ssh_key)

if(is.na(hash)) {
  warning("could not get hash on file")
  knitr::kable(unlist(p))
}

output_refreshed = F
      
table <- xfun::cache_rds({
  f <- get_file(needed_file, path=params$dir, ssh=ssh, ssh_key = params$ssh_key)
  output_refreshed <- ifelse(is.na(f), NA, T)
  message(paste("Reading file", f))
  table <- read.table(f, sep=";", header=T)
  if(!is.na(ssh)) file.remove(f)
  table
}, hash = list(hash), rerun = params$force)

```

<!--output_refreshed = `r output_refreshed`-->

```{r transforming_table}
table_long <- xfun::cache_rds({
  message("table_long generated")
  table |> 
    select( !starts_with("no_A", ignore.case = F)) |> 
    pivot_longer(cols= contains("enz") | contains("par"), names_to=c("what", "type"), values_to = "val", names_pattern = "(.*)_(.*)")
}, rerun = output_refreshed )
```


```{r transforming_table2}
table_A <- xfun::cache_rds({
  message("table_A generated")
  table |> 
    select( time:sd_M, starts_with("no_A", ignore.case = F)) |>
    pivot_longer(cols=starts_with("no_A", ignore.case = F), names_to= "type", values_to = "number", names_prefix = "no_")
}, rerun = output_refreshed)

```



## Properties of enzyme types

```{r plot_everything, eval=output_refreshed, fig.show='hide'}
ggplotly(ggplot(table_long, aes(x=time, y=val))+
  geom_line(aes(color=type))+
  facet_wrap(vars(what), scales = "free_y", ncol=2)#+
  #labs(caption = Sys.time())
)
```

![](`r knitr::fig_chunk('plot_everything', 'png')`)

## Cell diagnostics

```{r, echo=F, eval=T}
ggplot(table, aes(x=time, y=no_alive, color=replicators))+
   geom_point()+
   labs(x="Time [generations]", y="Number of vesicles with an active metabolism")
```

```{r plot_M, eval=output_refreshed, fig.show='hide'}
divide = sqrt(as.numeric(p$par_poolsize))
ggplotly(ggplot(table, aes(x=time, y=mean_M ))+
  #geom_errorbar(aes(ymin=mean_M - sd_M/sqrt(300), ymax=mean_M + sd_M/sqrt(300)), col="grey")+
  geom_ribbon(aes(ymin=mean_M - sd_M/divide, ymax=mean_M + sd_M/divide), fill="grey")+
  geom_line()
) 
```

![](`r knitr::fig_chunk('plot_M', 'png')`)

## Relicators by promiscuity levels

```{r plot_noA, eval=output_refreshed, fig.show='hide'}
ggplotly(ggplot( table_A, aes(x=time, y= number, fill=type))+
  geom_area()+
  coord_cartesian(ylim=c(0, as.numeric(p$par_poolsize) * as.numeric(p$par_splitfrom)))
) 
```

![](`r knitr::fig_chunk('plot_noA', 'png')`)
