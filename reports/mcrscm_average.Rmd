---
title: MCRSCM simulation results
author: "Dániel Vörös"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    self_contained: false
params:
  cache.path:
    label: Set path of cache folder
    value: "/home/danielred/data/programs/mcrs_to_scm/OUT/"
  dir:
    label: Path to data dir
    value: "/home/danielred/data/programs/mcrs_scm/OUT/bubble_fn2_693/"
  ssh:
    label: SSH address in format of user@domain:port
    value: "danielred@193.224.32.1:20343"
  ssh_key:
    label: Location of ssh public key
    value: ~/.ssh/id_rsa
  force:
    label: To force the document to regenerate all its plots
    value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r, setup, include=FALSE, message=F}
message("\ncache.path: ", params$cache.path,
        "\ndir: ", params$dir, 
        "\nssh: ", params$ssh, 
        "\nssh_key: ", params$ssh_key )

# set this option in the first code chunk in the document
knitr::opts_chunk$set(echo = F, cache.path=params$cache.path, cache.lazy = FALSE )

# libraries
library(RColorBrewer)
library(ggplot2)
library(tidyr)
library(lattice)
library(scales)
library(knitr)
library(dplyr)
library(plotly)
library(ssh)

# add_log <- function(x) {
#   layout(x, #title = 'myplot',
#             updatemenus = list(list(
#                 active = 0,
#                 direction="right",
#                 #type="buttons",
#                 buttons= list(
#                   list(label = 'linear',
#                        method = 'update',
#                        args = list(
#                          list(visible = c(T,F)), 
#                          list(yaxis = list(type = 'linear'), xaxis = list(type = 'linear'))
#                          )
#                        ),
#                   list(label = 'log-log',
#                        method = 'update', 
#                        args = list(list(visible = c(T,F)), list(yaxis = list(type = 'log'), xaxis = list(type = 'log')))), 
#                   list(label = 'log y',
#                        method = 'update', 
#                        args = list(list(visible = c(T,F)), list(yaxis = list(type = 'log'), xaxis = list(type = 'linear')))), 
#                   list(label = 'log x',
#                        method = 'update', 
#                        args = list(list(visible = c(T,F)), list(xaxis = list(type = 'log'), yaxis = list(type = 'linear')))) 
#                 )
#             ))
#   ) |> config(displaylogo = FALSE)
# }

par.orig <- par(no.readonly = T) # save default parameters

ssh <- ifelse(nchar(params$ssh)==0, NA, params$ssh)

```

```{r load_funcs, message=FALSE, cache=TRUE, cache.rebuild=params$force}
source("../functions.R")
source("../xml.R")
source("../composition.R")
source("../rnarep.R")
```

# simulation properties

```{r get_params, message=FALSE, cache=TRUE, include=FALSE}
check_dir(params$cache.path)
pf <- get_file("parameters.txt", mergepath(params$dir, "SAVE/"), ssh=ssh, ssh_key = params$ssh_key)
  if(!is.na(pf)){
    t <- readLines(pf)
    t <- read.table( text = sub(" ", "\t", t) , header=F, sep="\t")
    
    if(!is.na(params$ssh)) file.remove(pf)
    
    try(write.table(t, file="parameters.tsv", sep="\t", col.names = F, row.names = F))
    
    p <- as.list(as.character(t$V2))
    names(p) <- t$V1
  }
```


Simulation ID: **`r p$par_ID`**

Parameters:

```{r output_paramtable, cache=T, dependson="get_params"}
knitr::kable(unlist(p))
```

# Figures

```{r check_table}
# needed_file: the file I want to check if it has changed
# table: the data from needed_file
# output_refreshed: vaiable indicating if 

needed_file <- "output.csv"

hash <- get_mtime(needed_file, path=params$dir, ssh=ssh, ssh_key=params$ssh_key)

if(is.na(hash)) {
  warning("could not get hash on file")
  knitr::kable(unlist(p))
}

output_refreshed = F
      
table <- xfun::cache_rds({
  f <- get_file(needed_file, path=params$dir, ssh=ssh, ssh_key = params$ssh_key)
  output_refreshed <- ifelse(is.na(f), NA, T)
  message(paste("Reading file", f))
  table <- read.table(f, sep=";", header=T)
  if(!is.na(ssh)) file.remove(f)
  table
}, hash = list(hash), rerun = params$force)

```

<!--output_refreshed = `r output_refreshed`-->

```{r transforming_table}
table_long <- xfun::cache_rds({
  message("table_long generated")
  table_long = table |> 
    select( !starts_with("no_A", ignore.case = F)) |> 
    pivot_longer(cols= contains("enz") | contains("par"), 
                 names_to=c("what", "type"), 
                 values_to = "val", 
                 names_pattern = "(.*)_(.*)")
  if(nrow(table_long) > 2000000){
    warning("Too much data (", nrow(table_long), " lines), filtering out!")
    table_long = table_long[1:nrow(table_long) %% ceiling(nrow(table_long)/limit) == 0,]
  }
  table_long
}, rerun = output_refreshed )
```


```{r transforming_table2}
table_A <- xfun::cache_rds({
  message("table_A generated")
  table |> 
    select( time:sd_M, starts_with("no_A", ignore.case = F)) |>
    pivot_longer(cols=starts_with("no_A", ignore.case = F), names_to= "type", values_to = "number", names_prefix = "no_")
}, rerun = output_refreshed)

```

```{r, eval=F}
ggplot(table_long)+
  geom_line(aes(x=time, y=no_last_splits))
```


## Properties of enzyme types

```{r plot_everything, eval=output_refreshed, fig.show='hide'}
ggplotly(ggplot(table_long, aes(x=time, y=val))+
  geom_line(aes(color=type))+
  facet_wrap(vars(what), scales = "free_y", ncol=2)#+
  #labs(caption = Sys.time())
)

rm(table_long)
```

![](`r knitr::fig_chunk('plot_everything', 'png')`)

## Cell diagnostics

```{r Metplot, echo=F, eval=output_refreshed, fig.show='hide'}
ggplot(table, aes(x=time, y=no_alive, color=replicators))+
   geom_point()+
   scale_color_gradient(low="yellow", high="red")+
   labs(x="Time [generations]", y="Number of vesicles with an active metabolism")
```

![](`r knitr::fig_chunk('Metplot', 'png')`)

```{r plot_M, eval=output_refreshed, fig.show='hide'}
divide = sqrt(as.numeric(p$par_poolsize))
ggplotly(ggplot(table, aes(x=time, y=mean_M ))+
  #geom_errorbar(aes(ymin=mean_M - sd_M/sqrt(300), ymax=mean_M + sd_M/sqrt(300)), col="grey")+
  geom_ribbon(aes(ymin=mean_M - sd_M/divide, ymax=mean_M + sd_M/divide), fill="grey")+
  geom_line()
) 

rm(table)
```

## Relicators by promiscuity levels

```{r plot_noA, eval=output_refreshed, fig.show='hide'}
ggplotly(ggplot( table_A, aes(x=time, y= number, fill=type))+
  geom_area()+
  coord_cartesian(ylim=c(0, as.numeric(p$par_poolsize) * as.numeric(p$par_splitfrom)))+
  labs(x="Time (in generations)", y="Number of replcators with A activities", caption="accumulated areaplot!")
) 

rm(table_A)
```

# Unique figures


```{r check_savefiles}
openedpath = mergepath(params$cache.path, "opened.Rds")
savedpath = mergepath(params$cache.path, "savedata.Rds")


if(file.exists(openedpath) & !params$force) {
  opened <- readRDS(openedpath)
} else {
  opened <- character()
}

savefiles <- grep("*xml", get_filelist(path= mergepath(params$dir,"SAVE/"), ssh=ssh, ssh_key = params$ssh_key), value = T)
toread <- savefiles[!savefiles %in% opened]

if(params$force){
  toread <- savefiles
}

if(length(toread) > 0){
  newsave = T
} else {
  newsave = F
}

```


```{r load_savefiles, cache.rebuild=newsave}
if(file.exists(savedpath) & !params$force) {
  savedata <- readRDS(savedpath)
} else {
  savedata <- list()
  savedata$mosaic <- data.frame(source=character(), sA=character())
}

for(savefile in toread){
  # Read in file
  message("Reading in file ", savefile)
  
  # mosaic data
  try({
    comp = getLastComposition(filename(savefile), path=dirname(savefile), ssh=ssh, ssh_key = params$ssh_key, exclude = T)
    
    # do stuff
    oo <- do.call(rbind, lapply(comp, function(x, source) {
      data.frame(n=c(x),
                 type=names(x),
                 source=as.numeric(strsplit(filename(source), ".", fixed = T)[[1]][1]),
                 sA= comp2sA(as.numeric(names(x))) )
      
    }, source = savefile))
    savedata$mosaic <- rbind(savedata$mosaic, oo)
    rm(oo)
  }, silent = T)
  
  # finish
  opened <- c(opened, savefile)
}

# write opned.Rds
saveRDS(opened, openedpath)

# write savedata.Rds
saveRDS(savedata, savedpath)
```

```{r plot_mosaic_n, cache.rebuild=newsave, message=FALSE}
# dd$sA <- sapply(as.numeric(dd$type), function(x) {
#   types <- burstComposit(x)
#   paste(type2sA(types), collapse = "/")
# })

#sAcats = c("parazite","PARA/MONO","PARA/POLI","MONO/POLI","MONO/MONO","POLI/POLI")

if(nrow(savedata$mosaic) == 0 | !all(c("sA", "source") %in% colnames(savedata$mosaic)) ){
  warning("new saved data is present, but could not load it! Aborting...")
  knitr::knit_exit()
}

ddd = savedata$mosaic |> group_by(source, sA) |> summarise(n=sum(n))
ggplot(ddd)+
  geom_raster(aes(x=source, y=sA, fill=n))+
  labs(x="time", y="simple types")
```


```{r plot_mosaic_freq}
ddd = ddd |> group_by(source) |> mutate(freq=n/sum(n))

ggplot(ddd)+
  geom_raster(aes(x=source, y=sA, fill=freq))+
  labs(x="time", y="simple types")
```

```{r}
ggplot(ddd)+
  geom_line(aes(x=source, y=freq, color=sA))+
  labs(x="Time (in generations)", y="Frequency")#+
  #scale_color_continuous("Simple types")
```

